/**
 * This code was AUTOGENERATED using the codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  combineCodec,
  fixDecoderSize,
  fixEncoderSize,
  getBytesDecoder,
  getBytesEncoder,
  getStructDecoder,
  getStructEncoder,
  getU32Decoder,
  getU32Encoder,
  getU64Decoder,
  getU64Encoder,
  transformEncoder,
  type Address,
  type Codec,
  type Decoder,
  type Encoder,
  type IAccountMeta,
  type IAccountSignerMeta,
  type IInstruction,
  type IInstructionWithAccounts,
  type IInstructionWithData,
  type ReadonlyAccount,
  type ReadonlySignerAccount,
  type ReadonlyUint8Array,
  type TransactionSigner,
  type WritableAccount,
} from '@solana/web3.js';
import { BUBBLEGUM_PROGRAM_ADDRESS } from '../programs';
import { getAccountMetaFactory, type ResolvedAccount } from '../shared';
import {
  getMetadataArgsDecoder,
  getMetadataArgsEncoder,
  type MetadataArgs,
  type MetadataArgsArgs,
} from '../types';

export const VERIFY_COLLECTION_DISCRIMINATOR = new Uint8Array([
  56, 113, 101, 253, 79, 55, 122, 169,
]);

export function getVerifyCollectionDiscriminatorBytes() {
  return fixEncoderSize(getBytesEncoder(), 8).encode(
    VERIFY_COLLECTION_DISCRIMINATOR
  );
}

export type VerifyCollectionInstruction<
  TProgram extends string = typeof BUBBLEGUM_PROGRAM_ADDRESS,
  TAccountTreeAuthority extends string | IAccountMeta<string> = string,
  TAccountLeafOwner extends string | IAccountMeta<string> = string,
  TAccountLeafDelegate extends string | IAccountMeta<string> = string,
  TAccountMerkleTree extends string | IAccountMeta<string> = string,
  TAccountPayer extends string | IAccountMeta<string> = string,
  TAccountTreeDelegate extends string | IAccountMeta<string> = string,
  TAccountCollectionAuthority extends string | IAccountMeta<string> = string,
  TAccountCollectionAuthorityRecordPda extends
    | string
    | IAccountMeta<string> = string,
  TAccountCollectionMint extends string | IAccountMeta<string> = string,
  TAccountCollectionMetadata extends string | IAccountMeta<string> = string,
  TAccountEditionAccount extends string | IAccountMeta<string> = string,
  TAccountBubblegumSigner extends string | IAccountMeta<string> = string,
  TAccountLogWrapper extends string | IAccountMeta<string> = string,
  TAccountCompressionProgram extends string | IAccountMeta<string> = string,
  TAccountTokenMetadataProgram extends
    | string
    | IAccountMeta<string> = 'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s',
  TAccountSystemProgram extends
    | string
    | IAccountMeta<string> = '11111111111111111111111111111111',
  TRemainingAccounts extends readonly IAccountMeta<string>[] = [],
> = IInstruction<TProgram> &
  IInstructionWithData<Uint8Array> &
  IInstructionWithAccounts<
    [
      TAccountTreeAuthority extends string
        ? ReadonlyAccount<TAccountTreeAuthority>
        : TAccountTreeAuthority,
      TAccountLeafOwner extends string
        ? ReadonlyAccount<TAccountLeafOwner>
        : TAccountLeafOwner,
      TAccountLeafDelegate extends string
        ? ReadonlyAccount<TAccountLeafDelegate>
        : TAccountLeafDelegate,
      TAccountMerkleTree extends string
        ? WritableAccount<TAccountMerkleTree>
        : TAccountMerkleTree,
      TAccountPayer extends string
        ? ReadonlySignerAccount<TAccountPayer> &
            IAccountSignerMeta<TAccountPayer>
        : TAccountPayer,
      TAccountTreeDelegate extends string
        ? ReadonlyAccount<TAccountTreeDelegate>
        : TAccountTreeDelegate,
      TAccountCollectionAuthority extends string
        ? ReadonlySignerAccount<TAccountCollectionAuthority> &
            IAccountSignerMeta<TAccountCollectionAuthority>
        : TAccountCollectionAuthority,
      TAccountCollectionAuthorityRecordPda extends string
        ? ReadonlyAccount<TAccountCollectionAuthorityRecordPda>
        : TAccountCollectionAuthorityRecordPda,
      TAccountCollectionMint extends string
        ? ReadonlyAccount<TAccountCollectionMint>
        : TAccountCollectionMint,
      TAccountCollectionMetadata extends string
        ? WritableAccount<TAccountCollectionMetadata>
        : TAccountCollectionMetadata,
      TAccountEditionAccount extends string
        ? ReadonlyAccount<TAccountEditionAccount>
        : TAccountEditionAccount,
      TAccountBubblegumSigner extends string
        ? ReadonlyAccount<TAccountBubblegumSigner>
        : TAccountBubblegumSigner,
      TAccountLogWrapper extends string
        ? ReadonlyAccount<TAccountLogWrapper>
        : TAccountLogWrapper,
      TAccountCompressionProgram extends string
        ? ReadonlyAccount<TAccountCompressionProgram>
        : TAccountCompressionProgram,
      TAccountTokenMetadataProgram extends string
        ? ReadonlyAccount<TAccountTokenMetadataProgram>
        : TAccountTokenMetadataProgram,
      TAccountSystemProgram extends string
        ? ReadonlyAccount<TAccountSystemProgram>
        : TAccountSystemProgram,
      ...TRemainingAccounts,
    ]
  >;

export type VerifyCollectionInstructionData = {
  discriminator: ReadonlyUint8Array;
  root: ReadonlyUint8Array;
  dataHash: ReadonlyUint8Array;
  creatorHash: ReadonlyUint8Array;
  nonce: bigint;
  index: number;
  message: MetadataArgs;
};

export type VerifyCollectionInstructionDataArgs = {
  root: ReadonlyUint8Array;
  dataHash: ReadonlyUint8Array;
  creatorHash: ReadonlyUint8Array;
  nonce: number | bigint;
  index: number;
  message: MetadataArgsArgs;
};

export function getVerifyCollectionInstructionDataEncoder(): Encoder<VerifyCollectionInstructionDataArgs> {
  return transformEncoder(
    getStructEncoder([
      ['discriminator', fixEncoderSize(getBytesEncoder(), 8)],
      ['root', fixEncoderSize(getBytesEncoder(), 32)],
      ['dataHash', fixEncoderSize(getBytesEncoder(), 32)],
      ['creatorHash', fixEncoderSize(getBytesEncoder(), 32)],
      ['nonce', getU64Encoder()],
      ['index', getU32Encoder()],
      ['message', getMetadataArgsEncoder()],
    ]),
    (value) => ({ ...value, discriminator: VERIFY_COLLECTION_DISCRIMINATOR })
  );
}

export function getVerifyCollectionInstructionDataDecoder(): Decoder<VerifyCollectionInstructionData> {
  return getStructDecoder([
    ['discriminator', fixDecoderSize(getBytesDecoder(), 8)],
    ['root', fixDecoderSize(getBytesDecoder(), 32)],
    ['dataHash', fixDecoderSize(getBytesDecoder(), 32)],
    ['creatorHash', fixDecoderSize(getBytesDecoder(), 32)],
    ['nonce', getU64Decoder()],
    ['index', getU32Decoder()],
    ['message', getMetadataArgsDecoder()],
  ]);
}

export function getVerifyCollectionInstructionDataCodec(): Codec<
  VerifyCollectionInstructionDataArgs,
  VerifyCollectionInstructionData
> {
  return combineCodec(
    getVerifyCollectionInstructionDataEncoder(),
    getVerifyCollectionInstructionDataDecoder()
  );
}

export type VerifyCollectionInput<
  TAccountTreeAuthority extends string = string,
  TAccountLeafOwner extends string = string,
  TAccountLeafDelegate extends string = string,
  TAccountMerkleTree extends string = string,
  TAccountPayer extends string = string,
  TAccountTreeDelegate extends string = string,
  TAccountCollectionAuthority extends string = string,
  TAccountCollectionAuthorityRecordPda extends string = string,
  TAccountCollectionMint extends string = string,
  TAccountCollectionMetadata extends string = string,
  TAccountEditionAccount extends string = string,
  TAccountBubblegumSigner extends string = string,
  TAccountLogWrapper extends string = string,
  TAccountCompressionProgram extends string = string,
  TAccountTokenMetadataProgram extends string = string,
  TAccountSystemProgram extends string = string,
> = {
  treeAuthority: Address<TAccountTreeAuthority>;
  leafOwner: Address<TAccountLeafOwner>;
  leafDelegate: Address<TAccountLeafDelegate>;
  merkleTree: Address<TAccountMerkleTree>;
  payer: TransactionSigner<TAccountPayer>;
  /**
   * This account is checked to be a signer in
   * the case of `set_and_verify_collection` where
   * we are actually changing the NFT metadata.
   */
  treeDelegate: Address<TAccountTreeDelegate>;
  collectionAuthority: TransactionSigner<TAccountCollectionAuthority>;
  /**
   * If there is no collecton authority record PDA then
   * this must be the Bubblegum program address.
   */
  collectionAuthorityRecordPda: Address<TAccountCollectionAuthorityRecordPda>;
  collectionMint: Address<TAccountCollectionMint>;
  collectionMetadata: Address<TAccountCollectionMetadata>;
  editionAccount: Address<TAccountEditionAccount>;
  bubblegumSigner: Address<TAccountBubblegumSigner>;
  logWrapper: Address<TAccountLogWrapper>;
  compressionProgram: Address<TAccountCompressionProgram>;
  tokenMetadataProgram?: Address<TAccountTokenMetadataProgram>;
  systemProgram?: Address<TAccountSystemProgram>;
  root: VerifyCollectionInstructionDataArgs['root'];
  dataHash: VerifyCollectionInstructionDataArgs['dataHash'];
  creatorHash: VerifyCollectionInstructionDataArgs['creatorHash'];
  nonce: VerifyCollectionInstructionDataArgs['nonce'];
  index: VerifyCollectionInstructionDataArgs['index'];
  message: VerifyCollectionInstructionDataArgs['message'];
};

export function getVerifyCollectionInstruction<
  TAccountTreeAuthority extends string,
  TAccountLeafOwner extends string,
  TAccountLeafDelegate extends string,
  TAccountMerkleTree extends string,
  TAccountPayer extends string,
  TAccountTreeDelegate extends string,
  TAccountCollectionAuthority extends string,
  TAccountCollectionAuthorityRecordPda extends string,
  TAccountCollectionMint extends string,
  TAccountCollectionMetadata extends string,
  TAccountEditionAccount extends string,
  TAccountBubblegumSigner extends string,
  TAccountLogWrapper extends string,
  TAccountCompressionProgram extends string,
  TAccountTokenMetadataProgram extends string,
  TAccountSystemProgram extends string,
  TProgramAddress extends Address = typeof BUBBLEGUM_PROGRAM_ADDRESS,
>(
  input: VerifyCollectionInput<
    TAccountTreeAuthority,
    TAccountLeafOwner,
    TAccountLeafDelegate,
    TAccountMerkleTree,
    TAccountPayer,
    TAccountTreeDelegate,
    TAccountCollectionAuthority,
    TAccountCollectionAuthorityRecordPda,
    TAccountCollectionMint,
    TAccountCollectionMetadata,
    TAccountEditionAccount,
    TAccountBubblegumSigner,
    TAccountLogWrapper,
    TAccountCompressionProgram,
    TAccountTokenMetadataProgram,
    TAccountSystemProgram
  >,
  config?: { programAddress?: TProgramAddress }
): VerifyCollectionInstruction<
  TProgramAddress,
  TAccountTreeAuthority,
  TAccountLeafOwner,
  TAccountLeafDelegate,
  TAccountMerkleTree,
  TAccountPayer,
  TAccountTreeDelegate,
  TAccountCollectionAuthority,
  TAccountCollectionAuthorityRecordPda,
  TAccountCollectionMint,
  TAccountCollectionMetadata,
  TAccountEditionAccount,
  TAccountBubblegumSigner,
  TAccountLogWrapper,
  TAccountCompressionProgram,
  TAccountTokenMetadataProgram,
  TAccountSystemProgram
> {
  // Program address.
  const programAddress = config?.programAddress ?? BUBBLEGUM_PROGRAM_ADDRESS;

  // Original accounts.
  const originalAccounts = {
    treeAuthority: { value: input.treeAuthority ?? null, isWritable: false },
    leafOwner: { value: input.leafOwner ?? null, isWritable: false },
    leafDelegate: { value: input.leafDelegate ?? null, isWritable: false },
    merkleTree: { value: input.merkleTree ?? null, isWritable: true },
    payer: { value: input.payer ?? null, isWritable: false },
    treeDelegate: { value: input.treeDelegate ?? null, isWritable: false },
    collectionAuthority: {
      value: input.collectionAuthority ?? null,
      isWritable: false,
    },
    collectionAuthorityRecordPda: {
      value: input.collectionAuthorityRecordPda ?? null,
      isWritable: false,
    },
    collectionMint: { value: input.collectionMint ?? null, isWritable: false },
    collectionMetadata: {
      value: input.collectionMetadata ?? null,
      isWritable: true,
    },
    editionAccount: { value: input.editionAccount ?? null, isWritable: false },
    bubblegumSigner: {
      value: input.bubblegumSigner ?? null,
      isWritable: false,
    },
    logWrapper: { value: input.logWrapper ?? null, isWritable: false },
    compressionProgram: {
      value: input.compressionProgram ?? null,
      isWritable: false,
    },
    tokenMetadataProgram: {
      value: input.tokenMetadataProgram ?? null,
      isWritable: false,
    },
    systemProgram: { value: input.systemProgram ?? null, isWritable: false },
  };
  const accounts = originalAccounts as Record<
    keyof typeof originalAccounts,
    ResolvedAccount
  >;

  // Original args.
  const args = { ...input };

  // Resolve default values.
  if (!accounts.tokenMetadataProgram.value) {
    accounts.tokenMetadataProgram.value =
      'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s' as Address<'metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s'>;
  }
  if (!accounts.systemProgram.value) {
    accounts.systemProgram.value =
      '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
  }

  const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
  const instruction = {
    accounts: [
      getAccountMeta(accounts.treeAuthority),
      getAccountMeta(accounts.leafOwner),
      getAccountMeta(accounts.leafDelegate),
      getAccountMeta(accounts.merkleTree),
      getAccountMeta(accounts.payer),
      getAccountMeta(accounts.treeDelegate),
      getAccountMeta(accounts.collectionAuthority),
      getAccountMeta(accounts.collectionAuthorityRecordPda),
      getAccountMeta(accounts.collectionMint),
      getAccountMeta(accounts.collectionMetadata),
      getAccountMeta(accounts.editionAccount),
      getAccountMeta(accounts.bubblegumSigner),
      getAccountMeta(accounts.logWrapper),
      getAccountMeta(accounts.compressionProgram),
      getAccountMeta(accounts.tokenMetadataProgram),
      getAccountMeta(accounts.systemProgram),
    ],
    programAddress,
    data: getVerifyCollectionInstructionDataEncoder().encode(
      args as VerifyCollectionInstructionDataArgs
    ),
  } as VerifyCollectionInstruction<
    TProgramAddress,
    TAccountTreeAuthority,
    TAccountLeafOwner,
    TAccountLeafDelegate,
    TAccountMerkleTree,
    TAccountPayer,
    TAccountTreeDelegate,
    TAccountCollectionAuthority,
    TAccountCollectionAuthorityRecordPda,
    TAccountCollectionMint,
    TAccountCollectionMetadata,
    TAccountEditionAccount,
    TAccountBubblegumSigner,
    TAccountLogWrapper,
    TAccountCompressionProgram,
    TAccountTokenMetadataProgram,
    TAccountSystemProgram
  >;

  return instruction;
}

export type ParsedVerifyCollectionInstruction<
  TProgram extends string = typeof BUBBLEGUM_PROGRAM_ADDRESS,
  TAccountMetas extends readonly IAccountMeta[] = readonly IAccountMeta[],
> = {
  programAddress: Address<TProgram>;
  accounts: {
    treeAuthority: TAccountMetas[0];
    leafOwner: TAccountMetas[1];
    leafDelegate: TAccountMetas[2];
    merkleTree: TAccountMetas[3];
    payer: TAccountMetas[4];
    /**
     * This account is checked to be a signer in
     * the case of `set_and_verify_collection` where
     * we are actually changing the NFT metadata.
     */

    treeDelegate: TAccountMetas[5];
    collectionAuthority: TAccountMetas[6];
    /**
     * If there is no collecton authority record PDA then
     * this must be the Bubblegum program address.
     */

    collectionAuthorityRecordPda: TAccountMetas[7];
    collectionMint: TAccountMetas[8];
    collectionMetadata: TAccountMetas[9];
    editionAccount: TAccountMetas[10];
    bubblegumSigner: TAccountMetas[11];
    logWrapper: TAccountMetas[12];
    compressionProgram: TAccountMetas[13];
    tokenMetadataProgram: TAccountMetas[14];
    systemProgram: TAccountMetas[15];
  };
  data: VerifyCollectionInstructionData;
};

export function parseVerifyCollectionInstruction<
  TProgram extends string,
  TAccountMetas extends readonly IAccountMeta[],
>(
  instruction: IInstruction<TProgram> &
    IInstructionWithAccounts<TAccountMetas> &
    IInstructionWithData<Uint8Array>
): ParsedVerifyCollectionInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 16) {
    // TODO: Coded error.
    throw new Error('Not enough accounts');
  }
  let accountIndex = 0;
  const getNextAccount = () => {
    const accountMeta = instruction.accounts![accountIndex]!;
    accountIndex += 1;
    return accountMeta;
  };
  return {
    programAddress: instruction.programAddress,
    accounts: {
      treeAuthority: getNextAccount(),
      leafOwner: getNextAccount(),
      leafDelegate: getNextAccount(),
      merkleTree: getNextAccount(),
      payer: getNextAccount(),
      treeDelegate: getNextAccount(),
      collectionAuthority: getNextAccount(),
      collectionAuthorityRecordPda: getNextAccount(),
      collectionMint: getNextAccount(),
      collectionMetadata: getNextAccount(),
      editionAccount: getNextAccount(),
      bubblegumSigner: getNextAccount(),
      logWrapper: getNextAccount(),
      compressionProgram: getNextAccount(),
      tokenMetadataProgram: getNextAccount(),
      systemProgram: getNextAccount(),
    },
    data: getVerifyCollectionInstructionDataDecoder().decode(instruction.data),
  };
}
